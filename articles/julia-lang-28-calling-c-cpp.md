# 連結C/C++函式

這篇要如何用julia來呼叫C/C++的函式庫。Julia把跨語言的介面做得非常好。雖然python和matlab等高階語言也都有連結C/C++的能力，但都有一些不太方便的地方，有些語言的連結介面寫起來很不順，有些則是需要把C/C++的原始碼拿來重新編譯連結，而且大部份的高階語言在呼叫C/C++所需要的計算資源(overhead)很多。

julia設計的目的就是要滿足高效能運算的需求，而連結C/C++/Fortran函式庫當然也是不可或缺的功能。因些julia的設計團隊們也致力於改善這些缺陷。在效能上，由於julia也是根植於LLVM的編譯器架構，因此很容易就可以和同樣也是用LLVM編譯的C/C++函式庫整合，使得從julia呼叫C/C++函式所需要的計算資源和C/C++互相之間的函式呼叫可以很接近。另一個特色是julia的型別區分也和C/C++很接近，幾乎是可以一對一對映過去(julia也有指標(pointer)型別)，所以呼叫C函式的寫法非常自然。


julia呼叫C/C++函式用的是ccall()這個函式，它需要四個參數：

1. 一個(:function, library)的組合，用來決定要從那個library呼叫那個函式。julia目前的版本有個限制，就是被呼叫的函式庫必須在系統的shared library裡，所以如果要讓julia呼叫自訂的C/C++程式的話，必須在gcc之後加上"-shared"和"-fPIC"參數把compiled好的library丟到shared library裡。

2. C/C++的函式所傳回的型別

3. C/C++的函式的引數的型別

4. C/C++的函式的傳入值。


以下是一個簡單的例子，是官方文件上的:

```
julia> t = ccall( (:clock, "libc"), Int32, ())
1488043

``` 
這個ccall從libc這個函式庫裡執行clock()函式。它的結果很簡單，就是傳回目前的時間，是Int32表示，也不需要傳入任可引數。

另一個稍微複雜的例子是floor(double )函式(就是無條件捨去法)，它需要傳入一個浮點數，然後會傳回一個整數

```
julia> t = ccall( (:floor, "libc"), Float64, (Float64,), 2.2)
2.0
```

從上面兩個簡單的例子中，大家應該可以發現用julia呼叫C/C++真的很簡單，不需要重新編譯，也不需要另外寫一些C/C++的中介碼(glue code)，完全可以重覆使用現成的C/C++程式。這應該都要歸功於julia的型別設計，相對其他高階語言有點煩瑣，但在這個時候就更能看出它的好處。
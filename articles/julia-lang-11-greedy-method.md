---
title: 隨機的結果不好，那麼greedy呢?
---

今天我們來測試另一個簡單的AI實作，就是greedy演算法。一般人剛開始玩2048的時候大概就是用這個演算法，或是接近的思考模式:就是尋找會帶來最高分數的下一步。然而，這「最高分數」的定義就有點因人而異，或是因著盤面的變化而有所調整。有時候會傾向「可以拿最多分數」的下一步，而在盤滿愈來愈滿的時候，就會傾向找可以讓空白格增加的下一步。

以下是一個簡單的greedy實作，非常簡單，就只是選擇可以帶來最大分數的下一步。

```julia
function greedyAgent(board)

	legalMoves,score=getLegalMoves_score(board)
	assert(length(legalMoves)>0)

	if length(score)>1
		maxIndex=findfirst(score.==max(score...))
	else
		maxIndex=1
	end

	return legalMoves[maxIndex]

end
```

測試1000次的結果如下:






結果應該比完全隨機稍好，但還是很大進步的空間。一般的2048初心者如果沒有什麼特別的策略的話，分數也大概接近這個分布，就是數千分左右，運氣好一點的話可以破萬，但也就這樣。需要一些額外的學習和策略才有達到2048的機會。

使用進一步的AI會牽涉到大量的search，所以值得花一點時間來把之前的code進行最佳化來增加執行效率。(其實是因為我自己已經試了一些idea之後所以)
如果速度還是不夠的話，也會試著加進一些平行運算的技巧。前面的文章有提到，julia的執行效率可以相當接近C，但前提是程式碼要符合若干準則。
所以接下來會花一些篇幅來研究如何提升程式的效能。

